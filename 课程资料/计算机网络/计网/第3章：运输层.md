    ### 第三章

运输层位于应用层和网络层之间，运输层主要用于两个端系统之间的交付服务。

#### 运输层服务

运输层协议为不同主机上的进程提供了**逻辑通信**功能，且运输层协议是在端系统中实现的。

网络层协议与运输层协议的关系为：运输层协议负责收发整个端系统的应用层报文，将其**通过网络层协议传递给另一端的主机**，由运输层协议向进程分发报文。

因特网为应用层提供了两种不同的运输层协议：UDP和TCP，前者不可靠、无连接，后者可靠、面向连接，在设计网络应用程序时，需要指定使用哪种协议。

首先介绍因特网网络层协议IP(网际协议)，其服务模型是**尽力而为交付服务**，它尽最大努力交付报文段，但是不保证成功和顺序，所以是**不可靠服务**。

TCP为应用程序提供了几种附加服务：

- 可靠数据传输：通过流量控制、序号和定时器确保数据正确、按序交付给接收进程，将不可靠IP服务转换为可靠数据传输服务。
- 拥塞控制：防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备，尽可能为每个通过一条拥塞网络的线路平等想用带宽。

#### 多路复用和多路分解

接收主机的运输层并不是直接把数据交付给进程，而是交付给**套接字**。

将运输层报文段中数据交付到正确套接字的工作称为**多路分解**。

从源主机中不同套接字收集数据，并为每个数据块封装首部信息生成报文段，随后将其传递到网络层的工作称为**多路复用**。

运输层多路复用要求：

1. 套接字有**唯一标识符**。
2. 每个报文段有特殊字段来指示该报文段索要交付到的套接字，这些字段是**源端口号字段**和**目的端口号字段**。

因此分解服务的实现过程为：为主机上每个套接字分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，将其定向到相应的套接字。然后数据通过套接字进入所连接的进程。

##### 无连接的多路复用和分解

假设已经运行了以下代码：

```python
clientSocket = socket(AF_INET, SOCK_DGRAM)
clientSocket.bind(('', 19157))
```

创建了一个UDP套接字，同时使其关联端口号19157。若他要发送一个数据块给位于主机B的另一进程，该进程UDP端口号为46428.

主机A的运输层创建一个运输层报文段，其中包括应用程序数据，源端口号(19157)、目的端口号(46428)和两个其他值。然后运输层将得到的报文段传入网络层。网络层将报文段封装到IP数据报中，尽力而为交付给接受主机。

若到达了主机B，接受主机运输层就检查目的端口号(46428)，并将报文段交付给端口号46428标识的套接字。

UDP的套接字是由一个二元组全面标识的：目的IP地址和目的端口号。

源端口号的作用：若需要回发报文段时，就可以从源端口号取值回发。

##### 面向连接

TCP的套接字是由一个四元组：源IP地址，源端口号，目的IP地址，目的端口号来标识的。

因此当一个TCP报文段从网络到达主机，用全部4个值来将报文段定向到相应套接字。(与UDP不同的是，连个不同源IP地址或端口号的到达TCP报文段会被定向到两个不同的套接字)

TCP需要先向目的端口请求建立连接，在目的端口返回允许建立连接后，才开始传输数据。(三次握手)

即建立连接后，只有四元组完全相同的报文段，才能进入到这个套接字进行数据传输。

#### 无连接运输：UDP

使用UDP时，发送方和接收方是没有握手的，因此UDP被称为**无连接的**。

适合使用UDP的情况：

- 当不希望过分延迟报文段的发送，且能容忍数据丢失时(TCP会在链路拥塞时遏制运输层TCP发送方)
- 需要快速响应(TCP三次握手会有建立连接的时延，对于DNS等服务是不能接受的)
- 无连接状态。TCP需要在端系统中维护连接状态，使用UDP不跟踪连接参数，可以支持更多的活跃客户
- 分组首部开销小，TCP报文段有20字节首部开销，UDP只有8字节

UDP发送方引入的高丢包率容易引起TCP发送方大大减小速率(拥塞)，会挤垮TCP对话。

##### UDP报文段结构

UDP首部只有4个字段，每个字段由两个字节组成，分别为：源端口号、目的端口号、长度、校验和 组成

UDP检验和提供了差错检测功能。发送方的UDP将报文段中所有16比特字的和进行**反码运算**，求和时遇到的任何溢出都会被回卷。因此接收方收到文件时，将字和与检验和相加，应该会得到全是1的比特串，如果其中包含0，说明文件内容出了差错。

#### 可靠数据传输原理

TCP为上层实体提供的服务抽象是：数据可以通过一条可靠信道传输，即数据**按照顺序交付**，且**不会受到损坏和丢失**。

实现这种服务是**可靠数据传输协议**的责任。由于较低层是**不可靠**的点对点信道，我们需要考虑当底层信道损坏比特或者丢失分组时，应该需要怎样的协议机制。

我们仅考虑**单项数据传输**。

##### 构造可靠数据传输协议

从简单到复杂的协议研究，从而推导出可靠的数据传输协议。

###### 完全可靠信道的可靠数据传输：rdt1.0

最为简单的情况，底层信道是**完全可靠**的。此时rdt的接收端和发送端都仅需等待上/下层调用发送数据到信道即可，无需提供任何反馈信息。

###### 具有比特差错信道的可靠数据传输:rdt2.0

使用**自动重传请求协议**(ARQ)，使用肯定确认和否定确认。

此时需要三种协议功能来处理比特差错的情况：

- 差错检测。需要一种机制使接收方检测何时出现了比特差错，需要额外的比特来存储校验信息(比如检验码)
- 接收方反馈。接收方能够提供明确反馈信息给发送方，比如“肯定确认”(ACK)和“否定确认”(NAK)
- 重传。接收方收到有差错的分组时，发送方将重传该分组文

因此发送方在等待到上层调用后，还需要等待接收方反馈ACK或NAK。

而接收方仍为单一状态，收到调用后，要么回答ACK，要么回答NAK。

rdt2.0仍然存在一些致命的问题：ACK或NAK分组传回发送方时也可能受损。

因此解决此问题有这几种可能性：

- 收到ACK或NAK的发送方也回复ACK或NAK给接收方，但这样会非常混乱。
- 增加足够的检验和比特，使发送方不仅可以检测差错，也可以解决差错。
- 当发送方收到含糊不清的ACK或NAK，当作收到NAK重传数据即可。但是这种方法会在信道中引入**冗余分组**，即接收方不知道这条信息是重传还是一条新的分组。

为了解决这一问题，在数据分组中添加新字段，即分组的**序号**。一般只需有两个序号(0或1)。且接收方也可以反馈ACK 0和ACK 1来判断收到的是哪个分组。

###### 具有比特差错的丢包信道的可靠数据传输：rdt3.0

此时假设除了会比特受损外，底层信道还会丢包。

我们让发送方负责检测和恢复丢包工作，当发送方等待一整个往返时延加上处理放处理一个分组所需的时间之后，发送方可以确定丢包或数据缺失，从而重传分组。

所以为了实现以上的重传机制，需要一个**倒计数定时器**，在一个给定的时间量过期后，可中断发送方。

##### 流水线可靠数据传输协议

rdt3.0有个性能问题：它是一个**停等协议**，由于每次发送都要等待握手(等待接收方的ACK发送之后才能继续发送新的数据报)，实际信道利用率极低。

因此可以**不以停等方式运行**，即允许发送方发送多个分组而无需等待确认，这种技术称为**流水线**。

流水线技术对可靠数据传输协议会带来如下影响：

- 必须增加序号范围，因为每个输送中的分组必须有一个唯一的序号，而且也许有多个输送中的未确认报文。
- 发送方和接收方需要能够缓存多个分组。
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏的分组，处理差错有两个基本方法：**回退N步**和**选择重传**。

##### 回退N步(GBN协议) go-back N

允许发送方发送多个分组而不需等待确认，但流水线中未确认的分组数不能超过某个最大允许数N。

将base定义为最早未确认分组的序号，nextseqnum定义为最小的未使用序号(即下一个代发分组的序号)，[base, nextseqnum - 1]即为发送了但是待确认的分组。[nextseqnum, base + N - 1]为能用于立即发送的分组。

N被称为**窗口长度**，GBN协议也被称为**滑动窗口协议**。

GBN发送方必须响应三种类型的事件：

- 上层调用。当上层调用rdt_send()时，检查发送窗口是否已满，如果未满，则生成一个分组并发送，更新变量。若已满，将数据返回给上层，告诉上层窗口已满。
- 收到ACK。在GBN协议中，对序号为n的分组的确认采取**累积确认**。表明接收方已接收到序号为n即n以前的所有分组。
- 超时事件。如果出现超时，发送方重传**所有已发送但还未被确认过的分组**。

GBN中接收方只有前n-1个分组都成功接收，并第n个也接收，才会为第n个分组发送ACK。接收方**丢弃所有失序分组**。

##### 选择重传(SR)

GBN存在一些性能问题：单个分组的差错可能会导致大量分组的重传，可是其中大多分组没有必要进行重传。

因此，选择重传协议通过仅让发送方重传它怀疑在接收方出错的分组，这样可以避免其中不必要的重传。

即GBN中的滑动窗口无需按照顺序确认接收到的分组，只接受正确的分组，不管其是否按序。

发送方的事件：

1. 从上层收到数据。同GBN，序号在窗口内，发送；不在就缓存信息等待发送或者向上层返回无法发送。
2. 超时。每个分组都有一个逻辑定时器，因此超时发生后只需发送超时的分组。
3. 收到ACK。若收到ACK，且序号在窗口内，SR发送方的确认分组被设置为已接收。若序号等于send_base，则基序号向前移动到最小的未确认分组序号。如果有序号落在窗口内未发送的分组，则发送这些分组。

接收方的事件：

接收方同样也维护一个大小为N的接收滑动窗口。

1. 序号在[base, base + N - 1]内的分组被正确接收。同发送方，返回ACK，并且若序号为base，则窗口滑动，且将从base开始连续的分组发送给上层。若不是base，则**缓存分组**。
2. 如果序号在[base - N, base - 1]内的分组被正确收到，必须产生一个ACK。(考虑到ACK在回送时丢失导致发送方重发的情况)

且窗口大小N的长度一般不能大于序号的$\frac{1}{4}$，不然可能超时重发的分组到达接收方时可能被视为一个新的分组(比如序号范围为012，发送方发送012，接收方收到但是ACK丢失，发送方重发012，到达接收方时被视为新的分组)

#### 面向连接的运输：TCP

TCP是**面向连接**的，当一个进程向另一个进程发送数据之前，两个进程必须先相互握手，即互相发送某些预备报文段，以建立确保数据传输的参数。

TCP连接是**点对点**的，即只能是单个发送方到单个接收方之间的连接，不能将一个发送方的数据传给多个接收方。

当三次握手后，客户可以通过套接字传递数据流，TCP会将这些数据引导到**发送缓存**之中，接下来TCP会不时从发送缓存中发送数据到网络层。

TCP为每个客户数据搭配上一个TCP首部，从而形成多个TCP报文段，这些报文段被下传给网络层，网络层将其**封装在IP数据报**中。 

##### TCP报文段结构

首部字段包含和UDP同样的源端口号、目的端口号、检验和字段，也包含以下字段：

- 32比特的**序号字段**和32比特的**确认号字段**。用来实现可靠数据传输服务。
- 16比特的**接收窗口字段**，用户指示接收方愿意接收的字节数量。
- 4比特的**首部长度字段**。指示TCP首部长度(首部长度是可变的，选项字段可空可不空)
- 可选与变长的**选项字段**，该字段用于发送方与接收方协商最大报文段长度(MSS),或在高速网络环境作为窗口调节因子
- 6比特的标志字段。ACK比特用于确认字段值有效。RST、SYN、FIN比特用于连接的建立和拆除。在明确拥塞通告中使用CWR和ECE比特。当PSH比特置位时，表示接收方应立即将数据发给上层，URG比特表示报文段存在被上层实体置为“紧急”的数据。

##### 往返时间的估计与超时

###### 估计往返时间

报文段的样本RTT(表示为SampleRTT)就是某报文段被发出到确认之间的时间量，大多数TCP仅在某一时刻做一次SampleRTT测量。

但是SampleRTT会因为种种原因波动，因此需要维持一个SampleRTT均值，一旦获取一个新的SampleRTT，TCP会根据以下公式更新EstimatedRTT：

$EstimatedRTT=(1-\alpha)*EstimatedRTT+\alpha*SampleRTT$

$\alpha$的推荐值为0.125，这种计算出来的平均被称为**指数加权移动平均**。

且定义了DevRTT来估算SampleRTT偏离EstimatedRTT的程度，用于策略RTT的变化：

$DevRTT=(1-\beta)*DevRTT+\beta*|SampleRTT-EstimatedRTT|$

$\beta$的推荐值为0.25，如果波动小，DevRTT值小，反之就大。

###### 设置和管理重传时间间隔

超时间隔公式为：$TimeoutInterval=EstimatedRTT+4*DevRTT$

##### 可靠数据传输

之前假定的是每个已发送但是未确认的报文段都与一个定时器相关联，但是这样定时器的管理需要极大的开销。因此TCP协议之中仅使用单一的重传定时器。

以下是TCP发送方的简述：只用超时来恢复报文段的丢失，还是用冗余确认技术。

当接收方接收到比期望序号大的失序报文段，检测出间隔，则立即发送**冗余ACK**，表达中间有分组未到达，ACK序号为接收到的最后的连续序号。

当接收到三个冗余ACK时，TCP就执行**快速重传**，在定时器过期之前就重传丢失的报文段。

TCP更像是SR和GBN的结合体，TCP会缓存正确接收但是失序的报文段，因此至多重传一个报文段，即丢失的报文段n。

##### 流量控制

由于发送方接收方的速度不对等，直接全速传输可能导致缓存溢出，因此需要**流量控制服务**来匹配两方速度。

TCP通过让发送方维护一个称为**接收窗口**的变量来提供流量控制，用于告诉发送方接收方还有多少可用的缓存空间。因此当再传入文件会导致缓存溢出时，TCP会暂停发送方继续传输文件。

##### TCP连接管理

客户中TCP以以下方式与服务器中TCP建立一条TCP连接：

1. 客户端TCP首先向服务器端TCP发送一个特色TCP报文段，SYN位置1(SYN置1表示请求建立连接)。客户端会随机选择一个初始序号(client_isn)，将此放置在TCP SYN报文段的序号字段中(用于标识客户端发送数据包的顺序，由于是随机选数，需要维护一个序列号计数器)。
2. 一旦包含TCP SYN的报文段IP数据到达服务器，服务器会提取出报文段，为其连接分配TCP缓存和变量，并向TCP发送允许连接的报文段。SYN置1，确认号字段置为client_isn+1，服务器再选择自己的初始序号server_isn。该报文段称为**SYNACK报文段**。
3. 在收到SYNACK报文段后，客户也需要为连接分配缓存和变量，再发送一个报文段表示对服务器允许链接的报文段进行确认(将报文段首部确认字段置server_isn+1)，因为连接已经建立了，此时SYN比特置0。

随后可以进行数据传输。

当要终止TCP连接时，客户应用进程发送一个关闭连接命令，客户TCP向服务器发送一个特殊的TCP报文段，将其中的**FIN比特**置1，服务器收到后也返回一个确认报文段，FIN比特也置1，随后客户再次确认，最终释放用于连接的所有资源。

#### 拥塞控制原理

网络变得拥塞时会导致丢包的发生，为了减少这些情况，需要一些再面临网络拥塞时遏制发送方的机制。

##### 拥塞的原因与代价

大量的数据流量导致缓冲区溢出，大量丢包导致需要重传。

##### 拥塞控制方法

- 端到端拥塞控制。当TCP报文段丢失时，被认为是网络拥塞的迹象，因此TCP会减小报文段窗口长度，从而降低传输速度。
- 网络辅助的拥塞控制。路由器可向发送方反馈拥塞状态的显式反馈信息，用于表示链路中的拥塞情况。

#### TCP拥塞控制

TCP采用的方法是让每一个发送方根据所感知到的网络用拥塞都来限制器能向连接发送流量的速率。

首先分析TCP发送方如何限制器连接发送流量。TCP连接每一端都是由一个接收缓存、一个发送缓存和几个变量组成。运行时发送方的TCP拥塞控制机制跟踪一个额外的变量**拥塞窗口**(cwnd)，他对TCP向网络中发送流量的速率进行了限制。发送方中未被确认的数据量不会超过cwnd与(滑动窗口)rwnd中的最小值。 

将丢包事件定义为：出现超时，或收到来自接收方的3个冗余ACK。

如果没有丢包情况出现，即报文段成功传输，可以增加窗口长度(及其传输速率)。如果确认以相当慢的速率到达，窗口以缓慢速率增加，反之迅速增大。因为TCP使用确认来触发(或计时)增大它的拥塞窗口长度，TCP被说成**自计时**的。

以下是TCP拥塞控制算法的细节：慢启动、拥塞避免、快速恢复

1. 慢启动。当一条TCP连接开始时，cwnd的值通常为一个MSS的较小值，初始发送速率大概为MSS/RTT，由于对于发送方可用带宽可能大得多，TCP发送方希望迅速找到可用的带宽数量，因此在慢启动状态，cwnd每次乘2，当到一个设定的阈值或者出现阻塞情况时，慢启动状态结束。
2. 拥塞避免。一旦进入到拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，随后每个RTT只将cwnd的值增加一个MSS。当出现**超时时，cwnd的值被设置为1个MSS**，当**出现丢包时，ssthresh(标识何时从慢启动转为拥塞避免的状态)的值被更新为cwnd值的一半**，并进入快速恢复状态。
3. 快速恢复。在快速恢复中，对于引起TCP进入快速恢复状态的确实报文段，收到的每个冗余ACK，cwnd的值增加一个MSS，当丢失报文段的ACK到达时，cwnd再减小一个MSS。

因此拥塞窗口一般是线性增加一段后出现3个冗余ACK导致cwnd减半，特性为**加性增、乘性减**。cwnd呈**锯齿状**。

因此假设当前窗口长度为W，$一条连接的平均吞吐量=\frac{0.75\times W}{RTT}$

##### 公平性

多条TCP连接位于同一条链路时，应该平等地共享带宽。